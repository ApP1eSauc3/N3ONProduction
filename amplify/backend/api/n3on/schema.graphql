# ===============================
# groups used across the schema:
#   DJUser, VenueOwnerUser, UserGroup
# ===============================

type User 
  @model 
  @auth(rules: [
    { allow: groups, groups: ["VenueOwnerUser","DJUser","UserGroup"] }
  ]) {
  id: ID!
  username: String!
  avatarKey: String
  profileAudioKey: String
  beatBPM: Int
  # mirror of Cognito role so clients can see DJ status
  isDJ: Boolean! @default(value: "false")

  # Messages authored by this user (needs index on Message.senderID)
  messages: [Message] @hasMany(indexName: "bySender", fields: ["id"])

  # Chat rooms via join table
  chatRoom: [ChatRoom] @manyToMany(relationName: "UserChatRooms")

  venues: [Venue] @hasMany(fields: ["id"])

  # Reviews written by this user (needs index on Review.userID)
  review: [Review] @hasMany(indexName: "byUser", fields: ["id"])

  sentEndorsements: [EndorsementRequest] @hasMany(indexName: "byFromUser", fields: ["id"])
  receivedEndorsements: [EndorsementRequest] @hasMany(indexName: "byToUser", fields: ["id"])

  currentLatitude: Float
  currentLongitude: Float
  isSharingLocation: Boolean! @default(value: "false")
  sharingForEvent: ID
}

type Venue
  @model
  @auth(rules: [{ allow: groups, groups: ["VenueOwnerUser"] }] ) {
  id: ID!
  name: String!
  description: String!
  address: String!
  latitude: Float!
  longitude: Float!
  rating: Float
  imageKey: [String!]
  ownerID: ID!
  owner: User @belongsTo(fields: ["ownerID"])
  maxCapacity: Int
  currentUsers: Int
  revenue: Float

  # needs @hasMany pointing to DailyUserCount.byVenue index
  dailyUserCounts: [DailyUserCount] @hasMany(indexName: "byVenue", fields: ["id"])

  # needs @hasMany pointing to Review.byVenue index
  reviews: [Review] @hasMany(indexName: "byVenue", fields: ["id"])

  approvalStatus: String! @default(value: "PENDING")
}

type DailyUserCount
  @model
  @auth(rules: [{ allow: groups, groups: ["VenueOwnerUser"] }]) {
  id: ID!
  venueID: ID! @index(name: "byVenue", sortKeyFields: ["date"])
  venue: Venue @belongsTo(fields: ["venueID"])
  date: AWSDate!
  userCount: Int
}

type Review
  @model
  @auth(rules: [{ allow: groups, groups: ["UserGroup"] }]) {
  id: ID!

  # indexes so Venue.reviews and User.review can query efficiently
  venueID: ID! @index(name: "byVenue", sortKeyFields: ["createdAt"])
  venue: Venue @belongsTo(fields: ["venueID"])

  userID: ID! @index(name: "byUser", sortKeyFields: ["createdAt"])
  user: User @belongsTo(fields: ["userID"])

  rating: Float!
  comment: String!
  createdAt: AWSDateTime!
}

type ChatRoom 
  @model 
  @auth(rules: [
    # anyone in app roles can read rooms they learn about
    { allow: groups, groups: ["VenueOwnerUser","DJUser","UserGroup"], operations: [read] },
    # creator can create/update/delete
    { allow: owner, operations: [create, update, delete] }
  ]) {
  id: ID!
  name: String!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!

  participants: [User] @manyToMany(relationName: "UserChatRooms")

  # link to Message.byChatRoom index
  messages: [Message] @hasMany(indexName: "byChatRoom", fields: ["id"])

  lastMessage: String
  lastMessageTimestamp: AWSDateTime
  associatedEvent: ID
}

type Message 
  @model 
  @auth(rules: [
    # only the sender (owner) can create/update/delete
    { allow: owner, operations: [create, update, delete] },
    # all app roles can read messages (MVP). tighten later if needed.
    { allow: groups, groups: ["VenueOwnerUser","DJUser","UserGroup"], operations: [read] }
  ]) {
  id: ID!

  # index for User.messages
  senderID: ID! @index(name: "bySender", sortKeyFields: ["timestamp"])
  sender: User @belongsTo(fields: ["senderID"])

  # index for ChatRoom.messages
  chatRoomID: ID! @index(name: "byChatRoom", sortKeyFields: ["timestamp"])

  content: String!
  timestamp: AWSDateTime!
  isRead: Boolean!
  readBy: [String]
}

type Post
  @model
  @auth(rules: [{ allow: groups, groups: ["DJUser","UserGroup","VenueOwnerUser"] }]) {
  id: ID!
  urls: [String!]!
  types: [String!]!
  timestamp: AWSDateTime!
  caption: String
  ownerID: ID
}

type Ticket @model @auth(rules: [{ allow: owner }]) {
  id: ID!
  eventID: ID!
  userID: ID!
  quantity: Int!
  purchaseTime: AWSDateTime!
}

type Event @model @auth(rules: [{ allow: owner }]) {
  id: ID!
  venueID: ID!
  hostDJID: ID!
  djUsernames: [String!]!
  vjUsername: String
  package: String!
  requestNote: String
  eventDate: AWSDateTime!
  posterKey: String
  eventName: String!
  description: String!

  # Attendance has index byEvent â€” use it here
  attendances: [Attendance] @hasMany(indexName: "byEvent", fields: ["id"])

  attendees: [ID]!
  ticketPrice: Float!
  availableTickets: Int!
}

type EndorsementRequest 
  @model
  @auth(rules: [
    { allow: owner, operations: [create, read, update, delete] },
    { allow: groups, groups: ["DJUser"], operations: [read] }
  ]) {
  id: ID!
  fromUserID: ID! @index(name: "byFromUser", sortKeyFields: ["timestamp"])
  fromUser: User @belongsTo(fields: ["fromUserID"])
  toUserID: ID! @index(name: "byToUser", sortKeyFields: ["timestamp"])
  toUser: User @belongsTo(fields: ["toUserID"])
  message: String!
  status: String! # "pending", "approved", "rejected"
  timestamp: AWSDateTime!
}

type Attendance @model @auth(rules: [{ allow: owner }]) {
  id: ID!
  userID: ID! @index(name: "byUser")
  eventID: ID! @index(name: "byEvent")
  attendedAt: AWSDateTime!
  event: Event @belongsTo(fields: ["eventID"])
}
