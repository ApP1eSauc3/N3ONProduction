type User 
  @model 
  @auth(rules: [
    { allow: groups, groups: ["venueOwnerGroup", "djGroup", "userGroup"] }
  ]) {
  id: ID!
  username: String!
  avatarKey: String 
  profileAudioKey: String
  beatBPM: Int
  messages: [Message] @hasMany(fields: ["id"])
  chatRoom: [ChatRoom] @manyToMany(relationName: "UserChatRooms")
  venues: [Venue] @hasMany(fields: ["id"])
  review: [Review] @hasMany(fields: ["id"])
  sentEndorsements: [EndorsementRequest] @hasMany(indexName: "byFromUser", fields: ["id"])
  receivedEndorsements: [EndorsementRequest] @hasMany(indexName: "byToUser", fields: ["id"])
  currentLatitude: Float
  currentLongitude: Float
  isSharingLocation: Boolean! @default(value: "false")
  sharingForEvent: ID
}

type Venue
  @model
  @auth(rules: [{ allow: groups, groups: ["venueOwnerGroup"] }] ) {
  id: ID!
  name: String!
  description: String!
  address: String!
  latitude: Float!
  longitude: Float!
  rating: Float
  imageKey: [String!]
  ownerID: ID!
  owner: User @belongsTo(fields: ["ownerID"])
  maxCapacity: Int
  currentUsers: Int
  revenue: Float
  dailyUserCounts: [DailyUserCount] @hasMany(fields: ["id"])
  reviews: [Review] @hasMany(fields: ["id"])
  approvalStatus: String! @default(value: "PENDING")
}

type DailyUserCount
  @model
  @auth(rules: [{ allow: groups, groups: ["venueOwnerGroup"] }]) {
  id: ID!
  venueID: ID! @index(name: "byVenue", sortKeyFields: ["date"])
  venue: Venue @belongsTo(fields: ["venueID"])
  date: AWSDate!
  userCount: Int
}

type Review
  @model
  @auth(rules: [{ allow: groups, groups: ["userGroup"] }]) {
  id: ID!
  venueID: ID!
  venue: Venue @belongsTo(fields: ["venueID"])
  userID: ID!
  user: User @belongsTo(fields: ["userID"])
  rating: Float!
  comment: String!
  createdAt: AWSDateTime!
}

type ChatRoom 
  @model 
  @auth(rules: [
    { allow: owner }, 
    { allow: groups, groups: ["Users"] }
  ]) {
  id: ID!
  name: String!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  participants: [User] @manyToMany(relationName: "UserChatRooms")
  messages: [Message] @hasMany(fields: ["id"])
  lastMessage: String
  lastMessageTimestamp: AWSDateTime
  associatedEvent: ID
}

type Message 
  @model 
  @auth(rules: [
    { allow: owner, operations: [create, update, delete] },
    { allow: groups, groups: ["Users"], operations: [read] }
  ]) {
  id: ID!
  senderID: ID!
  sender: User @belongsTo(fields: ["senderID"])
  chatRoomID: ID! @index(name: "byChatRoom", sortKeyFields: ["timestamp"])
  content: String!
  timestamp: AWSDateTime!
  isRead: Boolean!
  readBy: [String]
}

type Post
  @model
  @auth(rules: [{ allow: groups, groups: ["djGroup", "userGroup", "venueOwnerGroup"] }]) {
  id: ID!
  urls: [String!]!
  types: [String!]!
  timestamp: AWSDateTime!
  caption: String
  ownerID: ID
}

type Ticket @model @auth(rules: [{ allow: owner }]) {
  id: ID!
  eventID: ID!
  userID: ID!
  quantity: Int!
  purchaseTime: AWSDateTime!
}

type Event @model @auth(rules: [{ allow: owner }]) {
  id: ID!
  venueID: ID!
  hostDJID: ID!
  djUsernames: [String!]!
  vjUsername: String
  package: String!
  requestNote: String
  eventDate: AWSDateTime!
  posterKey: String
  eventName: String!
  description: String!
  attendances: [Attendance] @hasMany(fields: ["id"]) 
  attendees: [ID]!
  ticketPrice: Float!
  availableTickets: Int!
}

type EndorsementRequest 
  @model
  @auth(rules: [
    { allow: owner, operations: [create, read, update, delete] },
    { allow: groups, groups: ["djGroup"], operations: [read] }
  ]) {
  id: ID!
  fromUserID: ID! @index(name: "byFromUser", sortKeyFields: ["timestamp"])
  fromUser: User @belongsTo(fields: ["fromUserID"])
  toUserID: ID! @index(name: "byToUser", sortKeyFields: ["timestamp"])
  toUser: User @belongsTo(fields: ["toUserID"])
  message: String!
  status: String! # "pending", "approved", "rejected"
  timestamp: AWSDateTime!
}

type Attendance @model @auth(rules: [{ allow: owner }]) {
  id: ID!
  userID: ID! @index(name: "byUser")
  eventID: ID! @index(name: "byEvent")
  attendedAt: AWSDateTime!
  event: Event @belongsTo(fields: ["eventID"])
}

type ChatRoom @model {
  id: ID!
  participants: [User] @manyToMany(relationName: "ChatRoomParticipants")
  isEventRoom: Boolean!
  eventID: ID
  createdAt: AWSDateTime
}
